
## Polymorphism (Method Overloading) in Java

### Polymorphism :-
- Poly (many) + Morphism (forms, structure)
- Real world example : sound, water, many brand clothes in one shop, person, single institute has multiple trainer etc
- Advantage :- It provides the flexibility to develop an application i.e. it allows us to perform a single task by different ways.
- Types of Polymorphism :-
  1. Compile Time Polymorphism
  2. Runtime Polymorphism
   
1.  Compile Time Polymorphism :-
   - It is also known as Static Polymorphism or Early Binding
   - If the polymorphism is achieved at compile time then it is known as compile time polymorphism
   - Compile Time Polymorphism can be achieved by 2 ways :-
     1. Method Overloading 
     2. Operator Overloading (is not supported in java except `+` symbol). (Why support `+`? because it is used for 2 different ways e.g. concatenation & Addition)
        - Those, who design the JAVA, people made in this way that Operator overloading never support except some symbols like +,-,/.
 
2.  Runtime Polymorphism :-
   - It is also known as Dynamic Polymorphism or Late Binding
   - If the polymorphism is existed at runtime then it is known as Runtime Polymorphism
   - Runtime Polymorphism can be achieved by "Method Overriding"

### Method Overloading :-
   - The process of compiler trying to resolve the method call based on reference type is known as method overloading.
     - ```
                                           Types
                                             |
                                             |
             |---------------------------------------------------------------------------|                   
             |                                      |                                    |
             \/                                     \/                                   \/
           Primitive Type                    Reference Type                            Null Type     
          8: boolean,char,byte,short,        class, interface, array, enum etc.
            int,float,double       
       ```
   - Rules for method overloading :-
     1. Same name
     2. Within same class
     3. Different parameters
            - No of parameters
            - Type of parameters
            - Sequence of parameters

   - What is reference type ?
   - What is parameter and argument ?

#### Note:
```java
class Test {
    void show(int a) // called parameter - declare proper variables
    {
        //  coding
    }

    public static void main(String args) {
        Test t = new Test();
        t.show(05);  // called argument - declare proper value of those variables
    }
}
```



### Interview Questions :-
1. Operator Overloading is not supported in java but + operator is overloaded
   - Operator Overloading concept is achieved only by java designers, but it cannot be achieved by developers like us.
2. What is difference between Compile Time Polymorphism & Runtime Polymorphism?
3. What is varargs?
4. Can we overload main method?
   - Yes
5. Can we overload constructors? 
   - Yes


```java
/*
 *
 *    - Rules for method overloading :-
 *    1. Same name
 *    2. Within same class
 *    3. Different parameters
 *           - No of parameters
 *           - Type of parameters
 *           - Sequence of parameters
 * */
class Test {
    void display() {
        System.out.println("1");
    }

    void display(int a) {
        System.out.println("2");
    }

    void display(int a, int b) {
        System.out.println("3");
    }
}

class MethodOverloading1 {
    public static void main(String[] args) {
        Test t = new Test();
        t.display();
        t.display(10);
        t.display(10, 20);
    }
}
/*
 * if you do void display() and void display() then
 * it gives error because
 * compiler will be confused which one(method) should be run.
 * */
```

```java
// Actual use of method overloading
class Test {
    void sum(int a, int b) {
        int res = a + b;
        System.out.println(res);
    }

    void sum(float a, float b) {
        float res = a + b;
        System.out.println(res);
    }
}

class MethodOverloading {
    public static void main(String[] args) {
        Test t = new Test();
        t.sum(10, 20);
        t.sum(10.4f, 20.7f);
    }
}
```

```java
// Type of parameters
class Test
{
    void display(String a)
    {
        System.out.println(a);
    }
    void display(int a)
    {
        System.out.println(a);
    }
}
class MethodOverloading2
{
    public static void main(String[] args)
    {
        Test t=new Test();
        t.display(10); // always call int type parameter method
        t.display("Dwarkesh"); // always call string type parameter method
    }
}
```
```java
// Sequence of parameters
class Test
{
	void display(String a, int b)
	{
		System.out.println(a+", "+b);
	}
	void display(int a, String b)
	{
		System.out.println(a+", "+b);
	}
}
class MethodOverloading3
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display(10, "Dwarkesh");
		t.display("Dwarkesk", 10);
	}
}
```


### Cases 


```java
class Test
{
	void display(int a)
	{
		System.out.println(a);
	}
	void display(char a)
	{
		System.out.println(a);
	}
}
class MethodOverloading4
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display(10);
		t.display('d');
	}
}
```

```java
class Test
{
	void display(int a)    // giving integer type
	{
		System.out.println(a);
	}
}
class MethodOverloading5
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display('d');      // giving char type    // output 100
        
        // if you just write above line and try to print
        // then it will not give you compile time error..
        // because it is automatic promoting (Widening Type Casting (Implicit Type Casting)) 
        // Also, it will not give you runtime error too because of Widening Type Casting
        // and also give ASCII value of the 'd'
        // if you do reverse then it will give error... see next example
		
        t.display(10);
	}
}
```
```
   
      boolean : not possible 
        
      byte => short => int => long => float => double
                        /\
                        ||
                       char
      ----------------------------------------->  Widening Type Casting (Implicit Type Casting) 
               (left to right)
               for char : char to int            -> lower data type to higher data type


      byte <= short <= int <= long <= float <= double
                        ||
                        \/
                       char
      <-----------------------------------------  Narrowing Type Casting (Explicit Type Casting)   
               (right to left)      
```

```java
class Test {
    void display(char a) {
        System.out.println("1 : " + a);
    }

}

class MethodOverloading_5_2 {
    public static void main(String[] args) {
        Test t = new Test();
        t.display(10); // error
        // because reverse not possible in automatic type casting
        // only left to right and for char, int & then next from right 
        t.display((char)10); //  Narrowing Type Casting (Explicit Type Casting)   
    }
}
```

```java
class Test
{
	void display(int a)
	{
		System.out.println("1 : "+a);
	}
	void display(char c)
	{
		System.out.println("2 : "+c);
	}
}
class MethodOverloading6
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display('d');
		t.display(10);
	}
}
```

```java
/*
 * Varargs : Variable Arguments
 * It means this will accept no argument, one argument, two argument, n number of arguments...
 * 
 * */
class Test
{
	void display(int a)
	{
		System.out.println("First method : "+a);
	}
	void display(int... a)      // called Varargs - Variable Arguments 
	{
		for(int i:a)   // for each loop
		{
			System.out.print(i+" ");
		}
		System.out.println();
	}
}
class MethodOverloading7
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display(); // we can write without creating the no arg constructor - because of the Varargs
		t.display(10); // first check for exact arg if not getting then go with Varargs 
		t.display(20,30); // we can write without creating the two args constructor - because of the Varargs
	}
}
```

```java
class Test
{
	void display(Object a)
	{
		System.out.println("1");        // default value of Object is null
	}
	void display(String a)              // default value of String is null
	{
		System.out.println("2");
	}
}
class MethodOverloading8
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display(null);        // check for child class if not available then call parent Object class		
	}
}
```

```
Understanding conceopt for above & below example:

here we are talking about default classes which JAVA made
from Object (parent class)  to other classes...classes inherit each other till getting parent class

If we have so many classes and their values are same then first it will call child class method then call above.... 
  

     __________
    |  Object  |                   parent class 
    |__________|                     
       /\
       ||      inherit
     ________
    | string |  <--------------first-call-----child-class------if-available------- for null value
    |________|
       /\
       ||     inherit
     _______
    |       |
    |_______|    
       /\
       ||     inherit
     _______
    |       |
    |_______|    
       /\
       ||     inherit
     _______
    |       |                  child class
    |_______| 

```


- Question: 
  - here we can see null value call first whatever child class is available if not then call Parent class i.e. Object
  - but in case of two child class is available at the same level then which one suppose to be called? 
  - see in below diagram

```
Understanding conceopt for above & below example:

here we are talking about default classes which JAVA made
from Object (parent class)  to other classes...classes inherit each other till getting parent class

If we have so many classes and their values are same then first it will call child class method then call above.... 
  

     __________
    |  Object  |      <------------ parent class 
    |__________|                     
       /\
       ||      inherit
     ________        --------------     ---------------    
    | string |      | StringBuffer |   | StringBuilder |    <------------ here we have same 3 String classes at the same level 
    |________|      |______________|   |_______________|
       /\
       ||     inherit
     _______
    |       |     <------------  child class
    |_______| 

```

```java
class Test
{
	void display(Object a)              // default value of Object is null
	{
		System.out.println("1");
	}
	void display(String a)             
	{ 
		System.out.println("2");
	}
	void display(StringBuilder a)
	{
		System.out.println("3");
	}
}
class MethodOverloading9
{
	public static void main(String[] args)
	{
		Test t=new Test();

		t.display(null);      // error + check for child class if not available then call parent Object class		
        // error: reference to display is ambiguous
        // here getting 2 different class of String, 
        // now compiler is getting confused
        // So, it will give you error at the compile time
        
		t.display("Dwarkesh");
		t.display(new StringBuilder("amit"));

		Object o=new Object();
		t.display(o);
	}
}
```
```java
/*
 * This program is not a program of the Method Overloading
 * This program will run without giving any error
 * other written-type will not consider in Method Overloading
 * same for final, static too.
 * 
 * Method Declaration and Method Definition
 * 
 * void display(int a)   ---> Method Declaration    -----|
 * {	                                                 |
 *      ............                                     |--------> Method Definition
 * }                                                -----|  
 * 
 * Method Definition: Combines the method declaration and the method body (implementation).
*  Method Declaration: Includes only the method signature (name, return type, and parameters) without the body.
 * */
class Test
{
	void display(int a)
	{
		System.out.println("1");
	}
	int display(String a) // Do not change written type -> void to int
	{
		System.out.println("2");
		return 0; 
        // this thing will not help us to do method overloading 
	}
}
class MethodOverloading10
{
	public static void main(String[] args)
	{
		Test t=new Test();
		t.display(10);
		t.display("Dwarkesh");
	}
}

```
```java
/*
 * This program will run and gives output  1.
 * */
class MethodOverloading11
{
	public static void main(String[] args)   // JVM only finds this method....
	{
		System.out.println("1");
	}
	public static void main(int[] args)  // this will not run because we need to call.. check next example
	{
		System.out.println("2");
	}
}
```
```java
// Can we overload main method? -> Yes we can..
class MethodOverloading11
{
	public static void main(String[] args)
	{
		System.out.println("1");

		MethodOverloading11 ob=new MethodOverloading11();
		int[] arr={10,20};
		ob.main(arr);
	}
	public static void main(int[] args)
	{
		System.out.println("2");
	}
}
```

```java
class MethodOverloading12
{
	public static void main(String[] args)
	{
		System.out.println("1");

		MethodOverloading12 ob=new MethodOverloading12();
		ob.main("Dwarkesh");
	}
	public static void main(String args)   // change type arr to String from previous example
	{
		System.out.println("2");
	}
}
Output:
1
2
```

````java
// Constructor Overloading 
class Test {
    Test() {
        System.out.println("1");
    }

    Test(int a) {
        System.out.println("2");
    }
}

class MethodOverloading13 {
    public static void main(String[] args) {
        Test t1 = new Test();
        Test t2 = new Test(10);
        // new Test();     // you can do in this way too, no need to create reference variable
        // new Test(10);   // you can do in this way too, no need to create reference variable
    }
}
````