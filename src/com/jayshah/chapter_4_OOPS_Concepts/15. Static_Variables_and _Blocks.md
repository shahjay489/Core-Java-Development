## Static variables and static blocks in Java


Hereâ€™s a simplified table for **Access Modifiers** and **Non-Access Modifiers**:

| **Access Modifiers**        | **Non-Access Modifiers** |
|-----------------------------|----------------------|
| `public`                    | `abstract`           |
| `protected`                 | `final`              |
| `private`                   | `static`             |
| `default` or `no modifier`  | `synchronized`       |
|                             | `volatile`           |
|                             | `transient`          |
|                             | `native`             |
|                             | `strictfp`           |

### static keyword :-
- static keyword is non-access modifier
- static keyword can be used with
  1. variables
  2. block
  3. methods
  4. nested class or inner class (not outer class)
- use of static keyword :-
  1. It is used to improve share-ability
  2. It is used for memory management
- static members belong to the class, not objects
   
### static variables :-
- If we declare any variable as static, it is known as static variable
- Static variables gets memory allocated in method area at the time of class loading.
- Example : see staticdemo1
- Note: class loading time means execute time (not exactly compile time - not exactly run time)

```
class A
{

}
class Test
{
    psvm main()
    {
        A ob = new A();
    }
}   
        
         -------   
        |       |  program java file  
        |_______| 
            ||      javac Test.java;
            \/      compilation process
         -------   -----                 
        |       | |     |  generate .class file (Test.class, A.class)
        |_______| |_____|
        
            ||      java Test;
            \/
        load in JVM   (remeber only load Test.java file)
                      (it will not load A.java file)
     ---------------------------------------------------------
    |                                       JVM               |
    |                                                         |
    |_________________________________________________________|
    
                    - when this line `A ob = new A();` will 
                      be executed at that time A.java file 
                      also laod in (JVM)memory. 
                    - This part known as class loading time.
                    - When this class file load at that time
                      memory is alloacted.

- while loading in JVM, if Test class has any static variable/block
  then, memory will be allocated to that static variable/block.
- But, in class A has any static variable/block that will not be allocated memory till the line `A ob = new A();` is executed. 
  Onced, line is executed that time it will be loaded in JVM and A class's static variable/block that will be allocated memory, too.
 (Class Loading Time.)
```

### Points to remember :-
1. We cannot create static local variable because main use of static variable is improved share-ability but local variables have limited share-ability thus it violates the rule of static keyword
2. If we declare any variable in static method, then it will be treated as local variable only
3. We cannot use instance variable inside static method, but we can use static variable inside instance method.

### static block :-
- A block created using static keyword is known as static block.
- Static block is executed at the time of class loading.
- Use of static block :-
  1. We can create static block to initialize static variables.
  2. We can create static block to load native libraries at class loading time.
- static blocks will be executed from top to bottom.
- Syntax :
   ```
   static
   {
      ....
   }
  ```


####  Interview Question :
1. Can we print hello without using main method?
   - Yes but before JDK 7 version
   


```java

/*
 * 1. main method execute
 * 2. create object e1 : store -> emp id,name,company
 * 3. create object e2 : store -> emp id,name,company
 * 4. create object e3 : store -> emp id,name,company
 * 
 * problem : here company name is same for every employee 
 *           and every time it allocates new memory to store. 
 *           if you want to count then you can check number of character,
 *          then size of character * number of character..
 *          SO, every time that number of memory use it..
 *          What, if I have a thousand of thousands object then,
 *          that much time it will generate and take new memory.
 * 
 * if instance variable then it allocates memory for each and every object.
 * if static variable then it allocate memory once and it shares with everyone.
 * */

//----------------------having problem of repeat company name-----------
class Employee
{
    int empid;
    String empname;
    String empcomname;

    Employee(int empid, String empname, String empcomname)
    {
        this.empid=empid;
        this.empname=empname;
        this.empcomname=empcomname;
    }

    void display()
    {
        System.out.println("---------Employee Details----------");
        System.out.println("Employee ID : "+empid);
        System.out.println("Employee Name : "+empname);
        System.out.println("Employee Company Name : "+empcomname);
        System.out.println();
    }
}
class StaticDemo1
{
    public static void main(String[] args)
    {
        Employee e1=new Employee(101, "Govardhan", "Vraj Mandal");
        Employee e2=new Employee(102, "Dwarkesh", "Vraj Mandal");
        Employee e3=new Employee(103, "Girirajji", "Vraj Mandal");

        e1.display();
        e2.display();
        e3.display();
    }
}


// ----------------Updated code-----------------------------
class Employee
{
	int empid;
	String empname;
    
    // it allocates memory just for the first time then 
    // it shares everytime...
    // everytime it will not allocate memory again and again..
	static String empcomname="Vraj Mandal"; // make static variable

    // String empcomname = "Vraj Mandal";  // Don not do this. why?
    
    /*
     you can not do like `String empcomname = "Vraj Mandal";` 
     this because it does the same thing...
     it allocates memory with each and every object..,,
     so, this will not fulfill the condition of the share-ability 
         and memory management
    */
    
    Employee(int empid, String empname)
	{
		this.empid=empid;
		this.empname=empname;
	}

	void display()
	{
		System.out.println("---------Employee Details----------");
		System.out.println("Employee ID : "+empid);
		System.out.println("Employee Name : "+empname);
		System.out.println("Employee Company Name : "+empcomname);
		System.out.println();
	}
}
class StaticDemo1
{
	public static void main(String[] args)
	{
		Employee e1=new Employee(101, "Govardhan");
		Employee e2=new Employee(102, "Dwarkesh");
		Employee e3=new Employee(103, "Girirajji");

		e1.display();
		e2.display();
		e3.display();
	}
}
```
- Note: here we can not use final keyword because `final` keyword use for the restriction and `static` keyword use for the share-ability or memory management.

```java
class PageVisitors {
    static int count = 0;

    PageVisitors() {
        count = count + 1;
        System.out.println("Visitor : " + count);
    }

    void noOfVisitors() {
        System.out.println(count);
    }
}

class StaticDemo2 {
    public static void main(String[] args) {
        PageVisitors v1 = new PageVisitors();
        PageVisitors v2 = new PageVisitors();
        PageVisitors v3 = new PageVisitors();
        PageVisitors v4 = new PageVisitors();
        PageVisitors v5 = new PageVisitors();

        v1.noOfVisitors(); // output: 5
        // v2, v3, v4, v5 - for all it will give same output i.e. 5 
        
        // if you do not make static then output will be 1.
    }
}


// output (having static variable)       output: non-static variable
    Visitor : 1                             Visitor : 1
    Visitor : 2                             Visitor : 1
    Visitor : 3                             Visitor : 1
    Visitor : 4                             Visitor : 1
    Visitor : 5                             Visitor : 1
    5                                       1


```


```java
/*
- if ypu make local variable static then its accessibility is within
    the method, you can use it outside the method.
- if you make static variable inside the method then? static is used for improve share-ability, 
    but local variable has share-ability only within the method,
    so it violate rules. 
*/
class StaticDemo3
{
	static int no1=10;

	void m1()
	{
		static int no2=20; // compile time error
	}
	public static void main(String[] args)
	{
		
	}
}
```

```java
/*
- we can not use static variable inside the static method.
- we can use non-static variable(simple variable) inside the static method.
- why? same rule of local variable - explain in above example..         
*/

class StaticDemo4
{
	static void m1()
	{
		//static int no2=20;  // error
		int no=10;
	}
	public static void main(String[] args)
	{
		
	}
}
```

```java

/*
 we can not use the simple variable(non-static variable) inside the static method.
- then what is the option?
    1.) make it static variable
    2.) create object of the class then call it..
*/
 
class StaticDemo5
{
    /*
     this will show an error.
     why??
     
       - we can use static variable inside the non-static method,
       - but we can not use non-static variable inside the static method.
       - because static variables gets memory allocated in method area at the time of class loading.
     
    int no=10;
    
    static void m1()
    {
        System.out.println(no);
    }
     */
    
    int no = 10;
    
	public static void main(String[] args)
	{
        // - create object of the class then call it. it will run
		// StaticDemo5 ob = new StaticDemo5();
		// System.out.println(ob.no);

		System.out.println(no);  // error
        /*
           We cannot use instance variable inside static method, 
           but we can use static variable inside instance method.
         */
	}
}
```

```

(total 5 method areas)
static int number = 10;
+-----------------------------------+
|  +-------+  +-------+  +-------+  |
|  |   10  |  |       |  |       |  |
|  +-------+  +-------+  +-------+  |
|   Method      heap       stack    |
|    area       area       area     |
+-----------------------------------+

in above graph, memory allacte inside the method area
because variable is static so when the class is loaded
that memory allocates to static variable. 

class StaticDemoExplain
{
    int number = 10;
    
    static void m1()
    {
        System.out.println(number);
    }
    
    psvm (String[] args)
    {
        StaticDemoExplain.m1(); // error
        // because number is not in any memory.
    }

}


- instance variable =>  int number = 10;
  it will come in memory area once we create the object of the class StaticDemoExplain.
  
- but if we make `static int number = 10;` then it will allocate memory in method area.
```
**REASON - very important point**
- here we try to run (above)this program then it will give the error
  because class through(or class name through) static method will call first. 
- that time in method, it has number(we use number inside the method) but number is not allocated in the memory. if we make the object or make it static then it will allocate. But, we do not do then number is not in memory, and we are calling method through object and in method we use number so that will give the error.

#### Note:
  - constructor: when we create object that time constructor will call automatically.  
  - method: by using object, method will call.
  - static block: when class load, that time it automatically executes.

constructor call while object creation time and method will call by using object.

```java
// static block
class StaticDemo7
{
	static
	{
		System.out.println("i am in static block");
	}

	public static void main(String[] args)
	{
		System.out.println("i am in main method");
	}
}
```

```java
class A {
    static {
        System.out.println("i am in static block class A");
    }
}

class StaticDemo8 {
    static {
        System.out.println("i am in static block class staticdemo");
    }

    public static void main(String[] args) {
        A ob = new A(); // if we do not write this line then?
        // when you do not load the class A,
        // then how that class's static block or static method will execute?  
        System.out.println("i am in main method");
    }
}

/*
Note:
    - if you do `A ob;` then still static block/method will not be executed. 
    - just for the doing reference creation, class file will not load in the memory
*/ 
```
```java
// Note: first always run static block
//     : top to down approach
//     : no need to call static block,
//       when the class load in the memory,
//       that time static block will call automatically

class StaticDemo9
{
	static
	{
		System.out.println("i am in static block class staticdemo 1");
	}

	public static void main(String[] args)
	{
		System.out.println("i am in main method");
	}

	static
	{
		System.out.println("i am in static block class staticdemo 2");
	}
}

Output:

i am in static block class staticdemo 1
i am in static block class staticdemo 2
i am in main method
```

```java
class StaticDemo10
{
	static
	{
		System.out.println("hello");    // first always run static block 
	}
	public static void main(String[] args)
	{
		System.out.println("hi");
	}
}

Output:
hello
hi
```

In **Java 1.7** (also known as **Java 7**), the **`main` method** was still required to run a Java application. However, starting from **Java 1.7**, Java allows the use of a **static block** (`static {}`) to execute code without needing the `main` method if the class has no `main` method.

#### Explanation:
- Prior to **Java 1.7**, the `main` method was required to run the application (the entry point).
- In **Java 1.7**, the Java Virtual Machine (JVM) was capable of recognizing and running a class that had a `static` block (even without a `main` method). However, this was not the usual practice, and the `main` method was still considered the standard entry point for running Java applications.

### Example in Java 1.7 or earlier (using a static block):
```java
public class HelloWorld {
    static {
        System.out.println("Hello from static block!");
        System.exit(0); // Exiting to prevent the program from looking for main()
    }
}
```

In this example:
- The program runs successfully without a `main` method, and the static block executes.
- **Note**: In a typical setup, `main` is still the convention, and using a static block without it is quite rare for typical Java applications.