## Nested Classes in Java

### Java Nested Class :-
- A class which is defined inside another class or interface is known as nested class
- Use of nested class :-
  1. Nested class enable you to logically group classes that are only used in on place which will increase the use of encapsulation.
  2. Nested class creates more readable and maintainable code.
  3. Nested class help to access the private members of outer class.

#### Types of Nested Class :-

1. Inner class
    - Member Inner Class
    - Method Local Inner Class
    - Anonymous Inner Class
2. Static Nested class  : (next file: 17. StaticMethods_Static_Nested_Class.md)

```
                   ______________
                  | Nested Class |
                  |______________|
                       /     \
                      /       \
                     /         \
                ____/____     __\_____________
               |  Inner  |   |  static nested |
               |  class  |   |   class        |
               |_________|   |________________|
                /   |   \
               /    |    \
              /     |     \
             /      |      \____________
       _____/__   __|___________   _____\______
      | Member | | Method local | | Anonymyous |
      | Inner  | | Inner        | | Inner      |
      | Class  | | Class        | | Class      |
      |________| |______________| |____________|
                 
```


   

#### Member Inner Class
- A class created within another class but outside the method is known as Member Inner Class
- Syntax :
    ```
    class Outer
    {
             class Inner    // Member Inner Class
             {
    
             }
    }
    ```
- Program :
    
    ```java
    class Outer
    {
        void show1()
        {
            System.out.println("1");
        }
        class Inner
        {
            void show2()
            {
                System.out.println("2");
            }
        }
    }
    class MemberInnerClass
    {
        public static void main(String[] args)
        {
            Outer ob1 = new Outer();
            ob1.show1();
    
            Outer.Inner ob2 = ob1.new Inner();
            ob2.show2();
        }
    }   
  ------------------------------------------------------------
  ------------------------------------------------------------
  
            ||
            ||   compile this program: javac MemberInnerClass
            \/
    # Note:
        - total 3 class will generate after compile the program
         - 1.) Outer.class
         - 2.) MemberInnerClass.class
         - 3.) Outer$Inner.class   // automatic generate by compiler
  
  - you can check by using this command: javap Outer$Inner
            you can see    >> final Outer this$0;
                              Outer$Inner(Outer);
                              void show2();
  
  
  // inside Outer$Inner class - generate by compiler
  class Outer$Inner
  {
        final Outer this$0;     // final variable
        // it can generate Outer class reference 
        // so you can remove Outer from the argument 
        Outer$Inner(Outer)      // constructor
        {
            super();  // when compiler generate the constructor
                      // in that case, super(); keyword will automatically add  
            this$0 = Outer.this;
        } 
        void show2()
        {
             ...........
        }     
  }
    ```

- Points to remember :-
1. Inner class name will be generated as OuterClassName$InnerClassName
2. Automatically outer class reference is created inside inner class

#### Method Local Inner Class :-
- When we create a class inside the method of another class, then it is known as method local inner class
- Syntax :
    ```
   class Outer
   {
      void methodName()
       {
           class Inner    // Method Local Inner Class 
           {
              ............
           }
       }
   }
   ```
- Points to remember :
1. We cannot invoke inner class method from outside the method
   
### Anonymous Inner Class
- A class that have no name and its name is generated by the compiler automatically, that class is known as anonymous inner class.
- It is used if we want to override method of class(concrete or abstract) or interface.
   

```java
// Nested class help to access the private members of outer class
class Outer
{
	private int a=10;
	class Inner
	{
		void show2()
		{
			System.out.println(a);
		}
	}
}
class MemberInnerClass2
{
	public static void main(String[] args)
	{
		Outer ob1=new Outer();
		Outer.Inner ob2=ob1.new Inner();
		ob2.show2();
	}
}
```


```java
// Member Inner Class
class Outer
{
	void show()
	{
		System.out.println("1");
		class Inner
		{
			void show2()
			{
				System.out.println("2");
			}
		}

		Inner i=new Inner();
		i.show2();
	}
}
class MethodLocalInnerClass
{
	public static void main(String[] args)
	{
		Outer ob=new Outer();
		ob.show();
	}
}
```
```java
// Member Inner Class : We cannot invoke inner class method from outside the method
class Outer
{
	void show()
	{
		System.out.println("1");
		class Inner
		{
			void show2()
			{
				System.out.println("2");
			}
		}
	}
	void show3()
	{
		Inner i=new Inner();     // error
		i.show2();              // error
	}
}
class MethodLocalInnerClass2
{
	public static void main(String[] args)
	{
		Outer ob=new Outer();
		ob.show3();
	}
}
```
```java
// Member Inner Class: can not provide any access modifier to inner class.
class Outer
{
	void show()
	{
		class Inner  // here you can not provide any access modifier 
        // error : private/public class Inner  {....}
		{
			public int a=10;  // you can provide any access modifier 
            // private, public ..
			void show2()
			{
				System.out.println(a);
			}
		}
		Inner i=new Inner();
		i.show2();
	}
}
class MethodLocalInnerClass3
{
	public static void main(String[] args)
	{
		Outer ob=new Outer();
		ob.show();
	}
}
```

```java
abstract class Vehicle
{
	abstract void start();
	abstract void showName();
}
class AnonymousInnerClass
{
	public static void main(String[] args)
	{
        // you can not create object of the abstract class,
        // but still you want to do then, must override all methods. 
		Vehicle v=new Vehicle()
		{
			void start()
			{
				System.out.println("starts with key");
			}
			void showName()
			{
				System.out.println("Tata Nexon");
			}
		};
		v.start();
		v.showName();
	}
}
```
```java
// Anonymous Inner Class  -- using abstract class 
/*
 * After compilation of this program then,
 * compiler will generate total 3 `.class` files.
 * - Vehicle.class
 * - AnonymousInnerClass2
 * - AnonymousInnerClass2$1 (generate by compiler) --> called Anonymous_Inner_Class
 * 
 * -> check prototype: javac AnonymousInnerClass2.java
 *                  : javap AnonymousInnerClass2
 * 
 * 
 * */
abstract class Vehicle
{
	abstract void start();
}
class AnonymousInnerClass2
{
	public static void main(String[] args)
	{
		Vehicle v=new Vehicle()
		{
			void start()
			{
				System.out.println("starts with key");
			}
		};
		v.start();
	}
}
/* 
 * -> check prototype: javac AnonymousInnerClass2.java
 *                   : javap AnonymousInnerClass2
 *
 * Compiler generate the AnonymousInnerClass2$1 class
 * (it is called Anonymous Inner Class, generated by compiler)
 * final class AnonymousInnerClass2$! extends Vehicle
 * {
 *      AnonymousInnerClass2$1();
 *      void start();
 * }
 * */


// ----------------------------------------
// what we suppose to do, but we did not do so compiler did it,
abstract class Vehicle
{
    abstract void start();
}

class Car extends Vehicle     <-------|
{                                     |                this class
    void start()                      |                we suppose to make
    {                                 | -------------> but we did not make it 
        .....                         |                so compiler did it
    }                                 |                and make new class - AnonymousInnerClass2$1         
}                             <-------|

class AnonymousInnerClass2
{
    public static void main(String[] args)
    {
        Vehicle v=new Vehicle()
        {
            void start()
            {
                System.out.println("starts with key");
            }
        };
        v.start();
    }
}

```

```java
// Anonymous Inner Class  -- using interface class
interface Vehicle
{
	void start();
}
class AnonymousInnerClass3
{
	public static void main(String[] args)
	{
		Vehicle v=new Vehicle()
		{
			public void start() // need to use public - otherwise gives error
			{
				System.out.println("starts with key");
			}
		};
		v.start();
	}
}
/*
 * -> check prototype: javac AnonymousInnerClass3.java
 *                   : javap AnonymousInnerClass3
 *
 * Compiler generate the AnonymousInnerClass3$1 class
 * (it is called Anonymous Inner Class, generated by compiler)
 * final class AnonymousInnerClass3$1 implements Vehicle
 * {
 *      AnonymousInnerClass3$1();
 *      public void start();
 * }
 * */
```

```java
// Anonymous Inner Class  -- using concrete(normal/simple) class
class Vehicle
{
	void start()
	{
		System.out.println("1");
	}
}
class AnonymousInnerClass4
{
	public static void main(String[] args)
	{
		Vehicle v=new Vehicle()
		{
			public void start()
			{
				System.out.println("starts with key");
			}
		};
		v.start();
	}
}
/*
 * -> check prototype: javac AnonymousInnerClass4.java
 *                   : javap AnonymousInnerClass4
 *
 * Compiler generate the AnonymousInnerClass4$1 class
 * (it is called Anonymous Inner Class, generated by compiler)
 * final class AnonymousInnerClass3$1 extends Vehicle
 * {
 *      AnonymousInnerClass4$1();
 *      public void start();
 * }
 * */
```