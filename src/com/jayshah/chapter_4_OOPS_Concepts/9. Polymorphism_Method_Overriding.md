
## Polymorphism (Method Overriding) in Java


```
                                 Polymorphism (advantage : Flexibility)
                                      |
                                      |
                  |--------------------------------------|                  
                  |                                      |               
                  \/                                     \/              
               Compile-time                             Runtime
               Polymorphism                          Polymorphism
                  /     \
                 /       \
              Method    Operator    
           Overloading  Overloading      
     

# Compile Time Polymorphism / Static Polymorphism / Early Binding
  - can be achieved by
            1. Method Overloading
            2. Operator Overloading   - Java does not suppot

# Runtime Polymorphism / Dynamic Polymorphism / Late Binding
  - can be achieved by
            1. Method Overriding
            
```
### Method Overriding :-
- The process of JVM trying to resolve the method call based on reference type is known as method overriding.
- Overriding is the feature by which child class trying to change the implementation of parent class method.
- Rules for method overriding :
  1. Same name
  2. Within different class
  3. Same parameters
     - No of parameters
     - Type of parameters
     - Sequence of parameters
  4. IS-A relationship

```java
class Parent
{
	void marry()
	{
		System.out.println("arrange marriage");
	}
	void greet()
	{
		System.out.println("namaste");
	}
}
class Child extends Parent
{
	void marry()
	{
		System.out.println("love marriage");
	}
	void greet()
	{
		System.out.println("hello dude");
	}
}
```

- Cases for method overriding :
1. If we change the return type in method overriding then it will provide compile time error.
2. We can provide child class as a return type for overriding method and this concept is known as Covariant return type
3. Child class method should have equal or higher access modifier as compared to parent method access modifier in method overriding
4. We cannot override private, final and static methods
5. We cannot override constructors
6. We cannot override main method

- Note: private methods and constructor can not inherit so if the inherit is not possible then override also not possible.

### Typecasting : The process of converting one data type into another is known as typecasting
#### Object Typecasting :
- The process of converting one object into another object is known as Object Typecasting
- Object typecasting is of 2 types :-
  1. Upcasting
  2. Down casting


```

                            |---------------|
                            |    Parent     |
                            |_______________|
                               /\      ||
                     UpCating  ||      ||   DownCasting
                               ||      \/
                            |---------------|
                            |    Child      |
                            |_______________|          
                            

# UpCating                                                         # DownCasting   
class A                                                             class A                            
{                                                                   {
    .....                                                              .....
}                                                                   }
class B extends A                                                   class B extends A
{                                                                   {
    .....                                                               .....
}                                                                   }                                              
class Test                                                          class Test
{                                                                   {
    public static void main(String[] args)                              public static void main(String[] args)
    {                                                                   {
        A obj = new B(); // implicite downcasting                           B obj = new A();   // error: automatic not possible - called implicite downcasting
    }                                                                         
}                                                                           // but still you want to do down casting then follow below 
                                                                            A obj = new B();
                                                                            B obj_temp = (B) obj;    // explit downlcasting
                                                                         }
                                                                     }



```


### Interview Questions :-
1. What is difference between method overloading & method overriding?

| **Feature**      | **Method Overloading**                                                                                            | **Method Overriding**                                                                                       |
|------------------|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| **Definition**   | The process of compiler trying to resolve the method call based on reference type is known as method overloading. | The process of JVM trying to resolve the method call based on reference type is known as method overriding. |
|                  |                                                                                                                   | Overriding is the feature by which child class trying to change the implementation of parent class method.  |
| **Rules for :-** | 1.) Same name.                                                                                                    | 1.) Same name.                                                                                              |
|                  | 2.) Within same class                                                                                             | 2.) Within different class                                                                                  |
|                  | 3.) Different parameters                                                                                          | 3.) Same parameters                                                                                         |
|                  | - No of parameters                                                                                                | - No of parameters                                                                                          |
|                  | - Type of parameters                                                                                              | - Type of parameters                                                                                        |
|                  | - Sequence of parameters                                                                                          | - Sequence of parameters                                                                                    |
|                  |                                                                                                                   | 4.) IS-A relationship                                                                                       |


2. What is upCasting & downCasting ?
   - UpCasting : Object typecasting in which child object is typecast into parent object
   DownCasting : Object typecasting which parent object is typecast into child object
   - UpCasting : Implicit upcasting is possible
   DownCasting : Implicit downCasting is not possible, but forcefully we can do i.e. explicit downCasting is possible
3. What is Covariant return type ?
   - Before JDK 1.5 version, Covariant return type concept was not there.
   - But in JDK 1.5 version and above version we can provide any child class as a return type for overriding method.
4. Which methods cannot override ?
   - private methods cannot override
   - final methods cannot override
   - static methods cannot override (method hiding concept)
  

```java

class A {
    void show1() {
        System.out.println("1");
    }
}

class B extends A {
    void show2() {
        System.out.println("2");
    }
}

class MethodOverriding1 {
    public static void main(String[] args) {
        A ob1 = new A();
        ob1.show1();

        B ob2 = new B();
        ob2.show2();
        
        // Upcasting
        A ob3 = new B(); // creating reference of the A class but making the object of the B class.
        // making B class object and point A class reference on that.
        
        ob3.show1();     // run without any error
        
        ob3.show2();	// compile time error: not possible 
        // we are making B class object
        // we are creating reference of the A class
        // this will call A class method ... hmmm but why? here is the thing  ---
        // we can not call B class's method through A class's reference. 
    }
}

Output:
        1
        2
        1
```   


```java
class A {
    void show() {
        System.out.println("1");
    }
}

class B extends A {
    void show() {
        System.out.println("2");
    }
}

class MethodOverriding2 {
    public static void main(String[] args) {
        A ob1 = new A();
        ob1.show();

        B ob2 = new B();
        ob2.show();

        A ob3 = new B();
        ob3.show();
        
        // here we did the same thing: making B class object and point A class reference on that.
        // All classes have the same method name.. so this is the concept of the Method OverLoading.
        // so this will call B class method not A class method
        // so first go to the child class then of not available then go to the parent class
    }
}

Output:
        1
        2
        2
```

```java
class A
{
	void show(int a)
	{
		System.out.println(a);
	}
}
class B extends A
{
	void show(int a)
	{
		System.out.println(a);
	}
}
class MethodOverriding3
{
	public static void main(String[] args)
	{
		A ob3=new B();
		ob3.show(20);
	}
}
```

```java
// this is not the example of the method overriding
// why?
// look - different parameter - read the rules
// this is the example of the Method Overloading 
class A
{
	void show(int a)
	{
		System.out.println(a);
	}
}
class B extends A
{
	void show(String a)
	{
		System.out.println(a);
	}
}
class MethodOverriding4
{
	public static void main(String[] args)
	{
		A ob3=new B();
		ob3.show(10);
	}
}
```

```java
/*
 * Giving compile time error
 * Can not change the return type
 * 
 * */
class A
{
	int show()
	{
		System.out.println("1");
		return 0;
	}
}
class B extends A
{
	void show()
	{
		System.out.println("2");
	}
}
class MethodOverriding5
{
	public static void main(String[] args)
	{
		A ob3=new B();
		ob3.show();
	}
}

```

```java
/*
 * Here we have changed the return type
 * but, in this case both return type also have the concept of inherit...
 * Here,we need to be very careful of the understanding
 * 
 * 
 * We can provide return type of the child class as subClass or parent class, too.
 * We can provide child class as a return type for overriding method and this concept is known as Covariant return type
 * 
 * What is Covariant return type ?
 *  - Before JDK 1.5 version, Covariant return type concept was not there.
 *  - But in JDK 1.5 version and above version we can provide any child class as a return type for overriding method.
 * */
class Parent
{
}
class Child extends Parent
{
}
class Child2 extends Parent
{
}
class A
{
	Parent show()                   // here we can not write `Child show()` - because of the down casting
	{
		System.out.println("1");
		return new Parent();
	}
}
class B extends A
{
	Child show()                // here we can not write `Parent show()` - because of the down casting
	{
		System.out.println("2");
		return new Child();
	}
}
class MethodOverriding6
{
	public static void main(String[] args)
	{
		A ob3=new B();
		ob3.show();
	}
}

```

- chart of the access modifier, for what we can change in the parent and child class...

| class    | access modifier | access modifier | access modifier | access modifier |
|----------|-----------------|-----------------|-----------------|----------------|
| `parent` | `default`       | `public`        | `protected`     | `private`      |
| `child`  | `public`        | `public`        | `public`        | NOT POSSIBLE   |
|          | `protected`     |                 | `protected`     |                |
|          | `private`       |                 |                 |                |

- private methods cannot override
- final methods cannot override
- static methods cannot override (method hiding concept)

#### why?
- static is the class level part.
- the method we make it is instance method, and it is for Object - so method overriding concept will not be possible.
- static concept for class & method part is dealing with the Object.  So, both can not d interact with each-other that's why.

```java
/*
 * Child class method should have equal or higher access modifier as compared to parent method access modifier in method overriding
 * We cannot override private, final and static methods
 * 
 * */
class A
{
	void show()         // by default access modifier is default
	{
		System.out.println("1");
	}
}
class B extends A
{
	public void show()    // here we changed access modifier from default to public
	{
		System.out.println("2");
	}
}
class MethodOverriding7
{
	public static void main(String[] args)
	{
		A ob3=new B();
		ob3.show();
	}
}
```

```java
/*
 * do not override main method because of the static
 * if you do then it is not the concept of the method override, but it is the method hiding concept.
 * 
 * */
class A
{
	public static void main(String[] args)
	{
		System.out.println("1");
	}
}
class B extends A
{
	public static void main(String[] args)
	{
		System.out.println("2");
	}
}
class MethodOverriding8
{
	public static void main(String[] args)
	{
		A ob3=new B();

		String[] str={"a", "b", "c"};
		ob3.main(str);
	}
}
```