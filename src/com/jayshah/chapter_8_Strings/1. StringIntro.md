### String Introduction in Java

#### String :-
- String is the sequence of characters or say String is an array of characters. 
- For example : `char[] c = {'d', 'e', 'e', 'p', 'a', 'k'};`
- To handle the character sequence, java has provided an interface i.e. CharSequence.
- String is a non-primitive data type. (Do not speak this line in interview because in Java, String is a class. Also, string is non-primitive data type you only say when you declare like `String name = "Govardhan";` Non-primitive data type - they do not have fix the size but when we create it that time it will have size. Here, we declare the value of the name variable i.e. 2 bytes * 9 total character = 18 bytes)


- String is a predefine class present in the `java.lang` package.

```
(chatgpt suggestion)
How to speack in the ingterview:

"String in Java is a reference type, not a primitive data type. 
It is implemented as a class and represents an array of characters. 
Each character in a String uses 2 bytes of memory (UTF-16 encoding), so if you have String name = "Govardhan";, it will use 9 characters Ã— 2 bytes = 18 bytes for the characters. 
Additionally, the String object itself has some overhead due to metadata and internal structure."
```


- To create String or to perform String operations, java has provided some predefined classes :-
1. java.lang.String
2. java.lang.StringBuffer
3. java.lang.StringBuilder
4. java.util.StringTokenizer

   
- Syntax :
  ```java
  public final class String extends Object implements Serializable, Comparable, CharSequence {
          // methods
  }
  /*
    here there are 3 interfaces:
        1.) Serializable : file input - output
        2.) Comparable : Collection
        3.) CharSequence : It made for Character Array
  
    - if we do not write extends Object then still it inherit Object class.
  */
  ```
- String is the class and we can create String class object. But we can create String class object by 2 ways :-
1. `String str=new String("Govardhan");`
2. `String str="Govardhan";`

- Whenever we create String class object, objects created are "`IMMUTABLE`"
  
- Whenever we create String objects, it allocates memory in special memory area i.e. "`String Constant Pool`" or "`String Literal Pool`"

- Garbage collection is not applicable for String Constant Pool.
   

```
JVM Architecture:

- Main 3 parts:
1.) Class Loader
2.) Memory Areas
3.) Execution Engine

- 2.) Memory Areas : Total 5 types
      a.) Method Area : sytatic variables, Class level information
      b.) Heap Area : Instance variable, Objects, Arrays, Strings (because String also an Object)
      c.) Stack Area : Local variables, Current running methods
      d.) PC Register
      3.) Native Method Area
     
   - This is a Stack
     |         | 
     |---------| 
     |         | 
     |---------| 
     |         | 
     |---------| 
     |_________| 
     
   - As we know String is in heap memory areas, there is also a one more area in heap areas provided by the java called SCP (String Constant Pool)
   - So, String java does memory occupy in heap area as well as in SCP, too.
     
```

```
                  JVM Architecture
     ______________________________________________________________________________________________________________
    |                                                                                                              |
    |    ____________________________________________________________________________                              |
    |   |                                                                            |                             |
    |   |                            Class Loader                                    |                             |
    |   |____________________________________________________________________________|                             |
    |                                                                                                              |
    |                              ______________                                                                  |
    |                             | Memory Area  |                                                                 |
    |    _________________________|              |______________________________________________________________   | 
    |   |                                                                                                       |  | 
    |   |    Method Area                          Heap Area                      Stack Area                     |  |
    |   |  |----------------------------|     |----------------------------|    |----------------------------|  |  |
    |   |  | 1. static variables        |     | 1. Instance variables      |    | 1. Local variables         |  |  |
    |   |  | 2. Class Level information |     | 2. Objects    ________     |    | 2. Current running methods |  |  |
    |   |  |----------------------------|     | 3. Arrays    |  SLP/  |    |    |----------------------------|  |  |  
    |   |                                     | 4. Strings   |  SCP   |    |                                    |  |
    |   |                                     |              |--------|    |                                    |  |
    |   |                                     |----------------------------|                                    |  |
    |   |                                                                                                       |  |
    |   |      PC Register         Native Method Area                                                           |  |
    |   |     |----------|        |------------------|                                                          |  |
    |   |     |          |        |                  |                                                          |  |
    |   |     |----------|        |------------------|                                                          |  |
    |   |                                                                                                       |  |
    |   |_______________________________________________________________________________________________________|  |
    |                                                                                                              |
    |    ___________________________________                                                                       |
    |   |           Execution Engine        |                                                                      |
    |   |___________________________________|                                                                      |
    |______________________________________________________________________________________________________________|

```

```

                                                         Heap Area
                                             -----------------------------------------------
                                            |                                               |
                                            |                                               |
                                            |                                               |
                                            |      ___________                              |
                               name   ------|---> | Govardhan |                          /--|-------- JVM will create
                                            |     |-----------|              ___________/   |       reference variable
                                            |                           ____|____           |      and that will point 
                                            |                          /    |    \          |      to this object
                                            |                         |     \/    |         |
                                            |                         | Govardhan |         |
                                            |                         |           |         |
                                            |              |----------|-->Dwarkesh|         |
                                            |              |          |           |         |
                                            |              |          \___________/         |
                               name2  ------|--------------|            SCP / SLP           |
                                            |                                               |
                                            |                                               |
                                            |_______________________________________________|
                  
                  
              We can create String Object in different ways..                              
                                            
              1.) create Object : String name = new String ("Govardhan");
                  - String name = new String ("Govardhan");  
                  - Object store in heap
                  - when new keyword: store in heap
                  - variable_name: name point to this object and object store value name Govardhan
                  - here we also creates String Literal - it writtens in "" so it also allocate memory in SCP: String Constant Pool
                  - so who refer that inside SCP? 
                  - JVM creates reference variable & internally refer(point) it 
                  
                  - SO, whenever we create new Object that time 2 objects are created.
                  - This is only for the String case.  
                  
              2.) String name2 = "Dwarkesh";       // String Literal
                  - here we do not use new keyword, so it will not allocate memory in heap area
                  - so it allocates the memory in the SCL (String Cionstant Pool)
                  - total 1 object is created.
                  
NOTE: 
    - in heap area, garbage collection can delete the object
    - but in SCL/SLP, garbage collection can not delete the objects
    - Garbage collection is not applicable for String Constant Pool. 

```


#### Difference between creating String objects by "new keyword" and by "String literal"
- If we create String object by using new keyword then an object is created in heap area. If we have provided any string literal in string constructor then 2 objects will be created and second object will be created in String Constant Pool.
  - Example: `String name = new String ("Govardhan");`


- If we create String object by using String literal then an object is created in String Constant Pool. 
  - Example: `String name2 = "Dwarkesh";`
   

```

String str1 = new String("Govardhan");  ----> 2 Objects
String str2 = new String("Govardhan");  ----> 1 Object

String str3 = "Dwarkesh;  ----> 1 Object
String str4 = "Dwarkesh;  ----> 0 Object


                                                         Heap Area
                                             -----------------------------------------------
                                            |                                               |
                                            |      ___________                              |
                               str1   ------|---> | Govardhan |                             |
                                            |     |-----------|                             |
                                            |      ___________                              |
                               str2   ------|---> | Govardhan |                             |
                                            |     |-----------|                             |
                                            |                           _________           | 
                                            |                          /         \          |
                                            |                         |           |         |
                                            |                         | Govardhan |         |
                               str3 --------|-------------------->|   |           |         |
                                            |                     |---|-->Dwarkesh|         |
                               str4 --------|-------------------->|   |           |         |
                                            |                         \___________/         |
                                            |                           SCP / SLP           |
                                            |                                               |
                                            |                                               |
                                            |_______________________________________________|
                  

Steps:

1.) String str1 = new String("Govardhan");
    - where memory allocate? here new keyword: (i.) heap, (ii.) SCP
    - here first creates 1 object in the heap area
    - str1 vaiabel name point this object
    - then check in SCP/SLP, if there is a object with same name literal is available or not
            - (here it does not have) if not then create new object 
    - So, total 2 objects are created
    
2.) String str2 = new String("Govardhan");
    - where memory allocate? here new keyword: (i.) heap, (ii.) SCP
    - here first creates 1 object in the heap area
    - str2 vaiabel name point this object
    - then check in SCP/SLP, if there is a object with same name literal is available or not
            - (here it does have) if available then it will not create new object 
    - So, total 1 object is created    

3.) String str3 = "Dwarkesh";
    - where memory allocate? here String literal: (i.) SCP
    - here first check in SCP/SLP, if there is a object with same name literal is available or not
            - (here it does not have) if not then it will create new object 
    - str3 vaiabel name point this object
    - So, total 1 object is created 

4.) String str4 = "Dwarkesh";
    - where memory allocate? here String literal: (i.) SCP
    - here first check in SCP/SLP, if there is a object with same name is available or not
            - (here it does have) if available then it will not create new object 
    - str4 vaiabel name point that object (which already available in SCP/SLP)
    - So, total 0 object is created  
    
```


#### Properties of "String Constant Pool" or "String Literal Pool"
1. SCP stores the String Literal Objects.
2. Whenever String Literal Object is created in SCP, first it will check weather that literal object is already present in SCP or not, if it is not present then it will create new object otherwise it will not create new object and that reference variable will point to that same object
3. Garbage Collection is not applicable in SCP

#### Why String objects are immutable ?
- immutable: Can not change. Not changeable.
- String objects are immutable which means that if we create any String object, then we cannot change its value.
- String objects are immutable because if we change any string object value, then it will create new object and will not affect other reference variables.
- NOTE : Strings are not immutable, String objects are immutable.
   

```
public class Test1 {
    public static void main(String[] args) {
        
        String name = "Govardhan";
        
        name = name.concat(" java");
        System.out.println(name); // output: Govardhan java
        
        name.concat(" java");
        System.out.println(name); // output: Govardhan
    }
}

1. what is the difference between this 2 output??
- String immutability : we can not change the String Object

            
                                           Heap Area
                               ------------------------------------------------
                              |                                                |
                              |                           ______________       | 
                              |                          /               \     |
String name = "Govardhan";    |                         |                 |    |
                 name --------|-------------------------|->Govardhan      |    |
                              |                         |                 |    |
name = name.concat(" java");  |                         | java            |    |     
                              |                     |---|->Govardhan java |    |
                 name --------|-------------------->|   |                 |    |
                              |                         \________________/     |
                              |                           SCP / SLP            |
                              |                                                |
                              |                                                |
                              |________________________________________________|
            
 1.) String name = "Govardhan";
  - first check name literal object is available in SCP or not?
      - if not (here it does not have) then create new Object : Govardhan
      
 2.) name = name.concat(" java");               
  - first check name literal object is available in SCP or not?
      - if not (here it does not have) then create new Object : java
  - now there is name.concat(" java"); and it stores in name. (i.e. name = name.concat(" java");)
  - java objects are immutable. So, it creates new object which stores "Govardhan java" 
  - So, before name pointed to "Govardhan", but now it points to "Govardhan java"

    OR OR OR 
    
2.) name.concat(" java");    
  - here, first check name literal object is available in SCP or not?
      - if not (here it does not have) then create new Object : java
  - now there is name.concat(" java"); (i.e. name.concat(" java");)
  - java objects are immutable. So, it creates new object which stores "Govardhan java" 
  - here in current senario, we do not provide any reference to store "Govardhan java".
  - that is why if you print name then you will get same output whihc is "Govardhan"
  
```


```
Why strings are immutable?
-->

    Java Application 
    ---------------
          Form
    name:
    email:
    password:
    gender: select any one M/F
    city:
    Register name btn
    
    
    
 - most of the form values are in String. 
 - So, that all are stroes in a SCP (SCP is inside Heap area) 
 - now new person come, which has the same name. 
 - so, name is pointes to the same object which is already made before in SCP.
 - Similary, if the data are same then it will not make new object in SCP,
 - but if the data is new then it will create new object in SCP.
 - for example: 
        - p1 
              name: Govardhan 
              Address: Vraj
        - p2
              name: Govardhan 
              Address: Nathdwara
        
        - in this example, name is same so in SCP only one name object will create,
        - but Address is difference so it will create new Address again.
        - p1 point to Vraj, p2 poin to Nathdwara 
        - p1,p2 name point to Govardhan        

           
Benefits | Advantages:
- Memory allocation and Object creation is lesser.
- same String literal not create new object. so our application will be faster.
- Think like, gender : M/F. if 1000 people fill this form then 1000 new objects would create.
- But because of SCP, Heap, immutable only 2 objects M & F are created 
- and then those 1000 people point to these 2 objects.
- Eventually, we save memory and same object recreation 

-> Why they make string object as immutable?
- As we seen, in above example, p1 point to Vraj, p2 poin to Nathdwara. 
- If tommorow, p2 change the value and make it different value
  then, if string is not immutable then it affects to other variables
  who point to the same object that is why string is immutable and
  next time it will create new object if it si not in SCP else make point to available object.

```



#### What String class is "final" ?
- String class is final because we cannot inherit String class and thus we were not able to change the String class properties
  Real world use of String final class and string immutable object.
- We can not extend String class, that is why we can not inherit String class property.
- So, we can not override the String class property, too. 
   

#### See Programs:
- [Test1.java](_1_String_Intro%2FTest1.java)
- [Test2.java](_1_String_Intro%2FTest2.java)


----------------------------------------------------

  | | | | | | | | | | | | | | |



--------------------------------------------------------
chatgpt
### Interview Questions: String

### 1. **Why is the `String` class `final`?**
**Answer:**
The `String` class is declared as `final` to ensure its immutability. Making the `String` class `final` means that it cannot be subclassed. This is important because the core feature of a `String` in Java is that it is immutable, meaning its value cannot be changed once it is created. Allowing subclassing could potentially allow modification of its behavior, which would violate the immutability contract and could lead to unexpected behaviors. By making `String` final, Java ensures that its immutability is preserved.

### 2. **Why does the `String` class implement `Comparable`?**
**Answer:**
The `String` class implements the `Comparable` interface to enable natural ordering of `String` objects. The `Comparable` interface has the `compareTo()` method, which allows objects to be compared to one another. For `String` objects, the `compareTo()` method compares two strings lexicographically (i.e., in dictionary order based on Unicode values of the characters). This allows `String` objects to be sorted in collections like `ArrayList` or used in data structures like `TreeSet` and `TreeMap`, where ordering is important.

### 3. **What is the purpose of `CharSequence` in the `String` class?**
**Answer:**
The `String` class implements the `CharSequence` interface, which is a more general interface for objects that represent a sequence of characters. Other classes that implement `CharSequence` include `StringBuilder` and `StringBuffer`. By implementing `CharSequence`, `String` can be treated in a uniform way with other sequence types, allowing for operations like `length()`, `charAt()`, `subSequence()`, and `toString()`. This makes the `String` class compatible with various APIs that expect a `CharSequence`.

### 4. **Why is `String` immutable?**
**Answer:**
`String` is immutable in Java for several important reasons:
- **Security:** Since strings are commonly used for credentials, file paths, and other sensitive data, immutability prevents accidental changes that could lead to security vulnerabilities.
- **Performance:** Immutable strings can be cached and shared across multiple references. The Java Virtual Machine (JVM) can reuse the same `String` object in multiple places, saving memory. This is known as the "string pool" optimization.
- **Thread Safety:** Immutability ensures that strings are inherently thread-safe. Multiple threads can safely use the same `String` without synchronization, as the content cannot change.

### 5. **What is the advantage of having `String` implement `Serializable`?**
**Answer:**
The `String` class implements the `Serializable` interface to allow `String` objects to be serialized and deserialized. Serialization is the process of converting an object into a byte stream so it can be easily saved to disk or sent over a network. By implementing `Serializable`, `String` objects can be included in this process. This is especially useful when storing or transmitting data in a distributed environment, such as when saving objects to files or sending them between different parts of a networked application.

### 6. **Why does `String` implement `Comparable` with a `compareTo` method?**
**Answer:**
The `String` class implements `Comparable` and provides the `compareTo()` method to allow for sorting and comparisons between `String` objects. The `compareTo()` method compares two strings lexicographically based on the Unicode value of each character in the string. It returns:
- A negative integer if the current string is lexicographically less than the other string,
- Zero if the two strings are equal, and
- A positive integer if the current string is lexicographically greater than the other string.

This implementation allows for `String` objects to be sorted in data structures like `TreeSet`, `TreeMap`, or even in a simple array using `Arrays.sort()`.

Yes, in an interview, questions about the `String` class can go beyond the ones we've already covered. Here are additional questions you might be asked, along with explanations for each. This will help you prepare comprehensively for interviews on the `String` class:

### 7. **What is the difference between `String`, `StringBuilder`, and `StringBuffer`?**
**Answer:**
- **String** is immutable, meaning once it is created, its value cannot be changed.
- **StringBuilder** and **StringBuffer** are mutable and are used when the string content needs to be modified.
- **StringBuffer** is thread-safe because its methods are synchronized, but this makes it slower compared to **StringBuilder**, which is not synchronized and thus faster but not thread-safe.
- **String** is best used for constant or unchanging text, while **StringBuilder** or **StringBuffer** should be used when dealing with a large number of modifications to the string content.

### 8. **What are the benefits of using the String pool?**
**Answer:**
The **String pool** (or string literal pool) is a special area in the heap memory where strings are stored. When you create a string literal, the JVM first checks if that literal already exists in the pool:
- **Memory Efficiency:** If the string is already in the pool, a reference to the existing string object is returned instead of creating a new object.
- **Performance:** It avoids duplicating string objects, saving memory and improving performance, especially in applications that use many identical string literals.

### 9. **What will happen if you try to modify a `String` object?**
**Answer:**
Since `String` is immutable, any operation that attempts to modify a `String` will actually create a new `String` object rather than modifying the original one. For example:
   ```java
   String s = "Hello";
   s = s.concat(" World");
   ```
In this case, the `concat` method creates a new `String` object with the value `"Hello World"`, and the reference `s` is updated to point to the new string, while the original `"Hello"` string remains unchanged.

### 10. **Explain the `String` constructor that takes a byte array.**
**Answer:**
The `String` class has a constructor that takes a byte array as an argument:
   ```java
   String(byte[] bytes)
   ```
This constructor creates a new `String` object using the bytes provided. The bytes are interpreted using the platform's default character encoding (such as UTF-8 or ISO-8859-1). This constructor is useful when dealing with binary data or when converting byte data (e.g., from a file or network stream) into a string representation.

### 11. **What is the significance of `String` being a subclass of `Object`?**
**Answer:**
Every class in Java implicitly extends the `Object` class, and `String` is no different. This gives the `String` class access to methods like `equals()`, `hashCode()`, and `toString()`:
- **`equals()`**: In `String`, the `equals()` method is overridden to compare the actual content of two strings (not their reference addresses).
- **`hashCode()`**: The `hashCode()` method is also overridden in `String` to generate a hash code based on the string's content, which is critical for hash-based collections like `HashMap` and `HashSet`.
- **`toString()`**: The `toString()` method in `String` simply returns the string itself, as strings are already textual representations.

### 12. **What is the `StringBuilder` and `StringBuffer` method `append()` used for?**
**Answer:**
Both **`StringBuilder`** and **`StringBuffer`** have the `append()` method, which is used to append data (like strings, characters, numbers, etc.) to the existing content of the string builder/buffer. The key difference is that `StringBuilder` is faster than `StringBuffer` because `StringBuffer` is synchronized and thread-safe, making `StringBuffer` slower when used in single-threaded environments.

### 13. **What is the difference between `==` and `.equals()` when comparing strings?**
**Answer:**
- **`==`**: The `==` operator compares **references**, not the actual content of the strings. If two string variables point to the same object in memory, `==` will return `true`. If they point to different objects, even if their contents are the same, it will return `false`.
- **`.equals()`**: The `equals()` method compares the **contents** of the strings, not their memory references. This means it checks if the characters within both strings are identical.

Example:
   ```java
   String s1 = "Hello";
   String s2 = "Hello";
   String s3 = new String("Hello");

   System.out.println(s1 == s2); // true, because they refer to the same object in the string pool
   System.out.println(s1 == s3); // false, because s3 refers to a different object
   System.out.println(s1.equals(s3)); // true, because the contents are the same
   ```

### 14. **How does the `String` class handle `null`?**
**Answer:**
A `String` can be `null`, meaning it does not point to any object. If you try to call methods like `length()`, `equals()`, or `substring()` on a `null` string, it will throw a **`NullPointerException`**. This is important to handle in code to prevent runtime errors, usually through null checks:
   ```java
   String s = null;
   if (s != null) {
       // Safe to call methods on s
   }
   ```

### 15. **How does the `String` class optimize performance when concatenating strings?**
**Answer:**
When concatenating strings using the `+` operator, the JVM internally uses a `StringBuilder` or `StringBuffer` to optimize the process. This is because strings are immutable in Java, so each concatenation would normally create a new `String` object. However, the compiler optimizes this by using a `StringBuilder` in the background to append the strings together, avoiding the creation of many intermediate `String` objects.

---

### Conclusion:
These questions cover the most important concepts around the `String` class, but the interview might also touch on **performance considerations**, **memory optimizations**, or **use cases in real-world scenarios** (e.g., why choose `String` over `StringBuilder` or vice versa). It's a good idea to familiarize yourself with these points as well as other related topics in Java's handling of strings, memory, and optimization.

Let me know if you'd like to explore any of these topics further or if you need more clarification!