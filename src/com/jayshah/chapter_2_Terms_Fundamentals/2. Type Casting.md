# Type Casting in Java


#### Data Types More Interview Questions :
1. What is ADT (Abstract Data Type)?
   - ADT is a type (or class) which holds the different types of objects with some specifications.
   - The definition of ADT only mentions what operations are to be performed but not how these operations implemented. (analogy: like main part is visible and backend is hide)
   - For examples : Stack ADT, List ADT, Queue ADT etc
   

2. Why java is not purely OOP's Langauge?
   - Java is not purely OOP's Langauge because:
   1. Usage of Primitive Data Types
   2. Usage of Static members


3. How primitive variables passed to methods - by value or by reference?
   - Java supports only pass by value
```java
class Test {
    
    public static void main(String[] args){
        Test test = new Test();
        test.sum (10,20);       // pass by value - directly gives value
    }
    
    void sum (int a, int b){
       System.out.println(a+b);
    }
}
```

4. What is type casting ?
   - The process of converting one data type to another data type known as type casting. 

5. What are different types of Type-Casting in java ?
   - There are 2 types of Type-Casting in Java :-
     1. "Primitive Data Type" Type Casting
        - 1.1: Widening Type Casting (Implicit Type Casting)
        - 1.2: Narrowing Type Casting (Explicit Type Casting)
     2. "User Defined Data Type" Type Casting
        

6. What is Type Checking & Type Casting ?
   

   - `Type Checking :` Type Checking is the responsibility of `compiler`. It checks whether the syntax is correct or not and whether we are assigning lower data type to higher data type.
   
   
   - `Type Casting :` Type Casting is the responsibility of `JVM`. In this phase lower data type (e.g. byte) will convert into higher data type (e.g. int) and the value will be copied in higher data type
   
### Type Casting :
   - The process of converting the data from one data type to another data type is known as type casting
   
#### There are 2 types of Type-Casting in Java :-


1. "Primitive Data Type" Type Casting:
   - we can cast only primitive data, called `Primitive Data Type.` 
   - in primitive data type, we have total 8 types but we can not cast `boolean` into any other data type. 
   - char can be casted only in int. => why? check the range of the char and int. char only fit in int.
- 1.1 Widening Type Casting (Implicit Type Casting) 
  - lower data type to higher data type
- 1.2 Narrowing Type Casting (Explicit Type Casting) 
  - higher data type to lower data type : not directly possible.
   

2. "User Defined Data Type" Type Casting


```
   
      boolean : not possible 
        
      byte => short => int => long => float => double
                        /\
                        ||
                       char
      ----------------------------------------->  Widening Type Casting (Implicit Type Casting) 
               (left to right)
               for char : char to int            -> lower data type to higher data type


      byte <= short <= int <= long <= float <= double
                        ||
                        \/
                       char
      <-----------------------------------------  Narrowing Type Casting (Explicit Type Casting)   
               (right to left)      
```

```java
class ImplicitTypeCastingDemo
{
   public static void main(String[] args)
   {
      byte b=10;
      int a=b;   // convert byte to int
      System.out.println("b : "+b);
      System.out.println("a : "+a);
   }
}

Output:
"b: 10"
"a: 10"
```

```java
class ImplicitTypeCastingDemo2
{
	public static void main(String[] args)
	{
		int a=10;
		byte b=a;
		System.out.println("b : "+b);
		System.out.println("a : "+a);
	}
}

Output:
error: incompatible types
     : possible lossy conversion from int to byte.
```


1. "Primitive Data Type" Type Casting
   
   - 1.1 Widening Type Casting (Implicit Type Casting)
     - It is the process of converting data from lower data type to higher data type
   
   - 1.2 Narrowing Type Casting (Explicit Type Casting)
     - In this case we convert higher data type into lower data type
     - Narrowing Type Casting can be achieved by using "cast operator"
    
- **Note** : 
  - no1 & no2 , result
  - no1 + no2 = result
    1. If no1 & no2 is byte, short or int then result will be always in int
    2. If no1 & no2 is long, float, double etc. then result will be in higher data type
   
```java
class ImplicitTypeCastingDemo3  // Widening Type Casting
{
	public static void main(String[] args)
	{
            byte a = 100;
            byte b = 200;
            byte c = a + b;
            System.out.println(c);
	}
}
Output:
error: incompatible types
     : possible lossy conversion from int to byte.

```
```java
class ImplicitTypeCastingDemo4  // Widening Type Casting
{
	public static void main(String[] args)
	{
            byte a = 100;
            byte b = 200;
            int bbi = a + b;
            System.out.println("bbi: "+ bbi);
            
            byte x = 100;
            short y = 100;
            int bsi = x + y;
            System.out.println("bsi: " + bsi);
            
            int p = 300;
            short q = 200;
            int isi = p + q;
            System.out.println("isi: " + bsi);
	}
}
Output:
bsi: 300
bsi: 200
isi: 500
```
```java
class ImplicitTypeCastingDemo5 // Widening Type Casting
{
	public static void main(String[] args)
	{
            byte a = 100;
            long b = 200;
            long c = a + b; // result will be store in higher data type
            System.out.println(c);
	}
}
Output:
200
```

```java
class ExplicitTypeCastingDemo1   // Narrowing Type Casting
{
	public static void main(String[] args)
	{
            int a = 50;
            byte b = a;
            System.out.println(b);
	}
}
Output:
error: incompatible types
     : possible lossy conversion from int to byte.

```

```java
class ExplicitTypeCastingDemo2   // Narrowing Type Casting
{
	public static void main(String[] args)
	{
            int a = 50;
            byte b = (byte)a;  // (int) called cast operator
            // called Narrowing Type Casting
            // called Explicit Type Casting
            System.out.println(b);
	}
}
Output:
50
```

```java
class ExplicitTypeCastingDemo3   // Narrowing Type Casting
{
	public static void main(String[] args)
	{
            int a = 50;
            short b = (short)a; // cast in short - save in short
            short c = (byte)a; // cast in byte - save in short
            System.out.println(b);
            System.out.println(c);
	}
}
Output:
50
50
```

```java
class ExplicitTypeCastingDemo3   // Narrowing Type Casting
{
	public static void main(String[] args)
	{
            byte a = 10;
            byte b = 20;
            
            byte c = a + b;  // error: incompatible types possible lossy conversion from int to byte.
            byte d = (byte)a + (byte)b; // error: same as above
            byte e = (byte)(a + b); // a+b gives output in int but it casts in byte
            System.out.println(e); 
            
            // multiple cast operator
            int p = 95;
            short q = (byte)(short)p; // value cast from int to short to byte and store into short
            System.out.println(q);
	}
}
Output:
30
95
```
```java
class ExplicitTypeCastingDemo4   // Narrowing Type Casting
{
	public static void main(String[] args)
	{
            int x = 130;
            byte y = (short)x;
            System.out.println(y);
       
            int p = 131
            byte q = (short)p;
            System.out.println(q);
	}
}
Output:
-126        // look output
-125        // look output
```
2. "User Defined Data Type" Type Casting

   - It is the process of converting data from one user defined data type to another user defined data type
   - For "user defined data type" type casting, both data types should have relation (either extends or implements)
      

```java

// Object is the parent class of the all classes..
// there is no parent class of the object class.. 
// Object class is the first Parent
class Object {
    
}

class String extends Object{  // String class does inherit Object class
   
}
Class Test {
   String name = "Govardhan";
   Object o = (Object) name;  // String cast into Object
    // String and Object both have relation that is the reason we can cast it.
}
```

-------------------------------------------------------------------------

Summary:

Here's a chart that illustrates **Widening (Implicit) and Narrowing (Explicit) Type Casting** in Java, including the potential for data loss, precision loss, and required explicit casting.

### **Type Casting in Java**

| **Casting Direction**           | **From**        | **To**             | **Implicit (Widening)** | **Explicit (Narrowing)** | **Risk of Data Loss**  | **Risk of Precision Loss** |
|---------------------------------|-----------------|--------------------|------------------------|--------------------------|------------------------|----------------------------|
| **Char to Smaller Types**       | `char`          | `byte`             | ❌ (explicit)          | ✅ (explicit)            | **Yes**                | **No**                     |
|                                 |                 | `short`            | ❌ (explicit)          | ✅ (explicit)            | **Yes**                | **No**                     |
|                                 |                 | `int`              | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `long`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `float`            | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
| **Byte to Larger Types**        | `byte`          | `char`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `short`            | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `int`              | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `long`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `float`            | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
| **Short to Larger Types**       | `short`         | `char`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `int`              | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `long`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `float`            | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
| **Int to Larger Types**         | `int`           | `long`             | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `float`            | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
|                                 |                 | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **No**                     |
| **Long to Larger Types**        | `long`          | `float`            | ✅ (implicit)          | ❌                       | **No**                 | **Yes** (potential precision loss) |
|                                 |                 | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **Yes** (potential precision loss) |
| **Float to Double**             | `float`         | `double`           | ✅ (implicit)          | ❌                       | **No**                 | **Yes** (potential precision loss) |
| **Explicit Casting**            | **Any type to Smaller Types** | **Char to Byte/Short/Int/Long/Float/Double** | ❌ (implicit)            | ✅ (explicit)            | **Yes** (Data loss may occur) | **Yes** (Precision loss) |

### **Key Concepts and Examples**:

#### **Widening (Implicit) Type Casting**:
- Happens automatically when converting from a **smaller** data type to a **larger** data type.
- No need for explicit casting (Java does it for you).
- Example: `char` to `int`, `byte` to `long`.

##### **Examples**:
```java
char ch = 'A';
int num = ch;  // Implicit cast from char to int
```

```java
byte b = 10;
long l = b;  // Implicit cast from byte to long
```

#### **Narrowing (Explicit) Type Casting**:
- Requires **manual casting** when converting from a **larger** data type to a **smaller** data type.
- **Risk of data loss**: Smaller data types may not be able to hold the larger value, leading to overflow or truncation.
- **Risk of precision loss**: When converting between floating-point types like `double` to `float`.

##### **Examples**:
```java
int num = 65;
char ch = (char) num;  // Explicit cast from int to char
```

```java
double pi = 3.14159265358979;
float piFloat = (float) pi;  // Explicit cast from double to float (precision loss)
```

### **Important Considerations**:
- **Explicit Casting** is needed when there's a risk of losing data, such as converting from a larger to a smaller data type (`long` to `int`, `double` to `float`).
- **Implicit Casting** is safe and does not lose data, but only works when converting from smaller types to larger types.
- **Data loss** happens if the value cannot fit into the target type (e.g., `int` to `byte` or `long` to `short`).
- **Precision loss** occurs when converting floating-point types (`double` to `float`) or when casting between integers and floating-point numbers.

---

### **Summary**:
- **Widening** (Implicit) Type Casting: Safe, automatic, from **smaller** to **larger** types.
- **Narrowing** (Explicit) Type Casting: Manual, from **larger** to **smaller** types, with potential for **data loss** and **precision loss**.
